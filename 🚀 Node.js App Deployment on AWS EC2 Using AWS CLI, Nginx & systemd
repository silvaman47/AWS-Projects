This project demonstrates how I deployed a simple Node.js application on an AWS EC2 instance using only the AWS CLI, and set it up with Nginx as a reverse proxy and systemd for process management.

  ## üîß Tools & Technologies Used

- **AWS CLI**
- **Amazon EC2 (Ubuntu Server)**
- **Node.js & Express**
- **Nginx**
- **systemd**
- **Git + GitHub**

  ## üìÅ Project Structure

project/
‚îú‚îÄ‚îÄ server.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env
‚îî‚îÄ‚îÄ README.md

Before getting started, I had to install AWS CLI on my local machine. This would allow me to interact with AWS services via commands in a command line environment. In line with AWS best practices,
I created an IAM User in my root account and assigned AdministratorAccess for this project as well as future projects. Afterwards, I generated secret credentials for my IAM User which consist of an aws access key id 
aws secret access key. These keys will later be used after installing AWS CLI for configuration.

To install AWS CLI, I referenced the documentation at 'https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html#getting-started-install-instructions' and used the command 'msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi'
in my windows powershell terminal to download the installer, after which i followed the prompts in the installation wizard to complete the installation. After closing and reopening windows powershell, I was able to 
use the command 'aws configure' to set my required parameters which consist of the aws access key id, aws secret access key, default region name and default output format.
[Image]
Now having configured my AWS CLI, i proceeded to provision an EC2 instance. The instance would serve as the platform for configuration and deployment of my node.js application. To do this, a group security group first has to be created. This is done to provide instance level security
meaning you decide which from which ports and IP Address ranges traffic is allowed to enter and exit your EC2 instance. 
[Image]
After creating the security group, we configure the protocol, port and cidr block for the previously creates security group. In this case, ports 22 for SSH, 80 for HTTP and 3000 for our test server are allowed for our EC2 instance.
0.0.0.0/0 here indicates that any IP address is able to send network traffic to the instance. It is not a recommended practice however for demonstration purposes, i configured it this way.
[Image]
With the prerequisites out of the way, I proceeded to launch my EC2 instance. as shown in the image, an image id is required to identify what type of virtual machine i aimed to launch, the instance type here being the
kind of virtual machine im provisioning. In this case a t2.micro is enough to suit the needs of this project. It is a free tier eligible instance type and its for general purpose use cases.
count refers to the number of machines of this type i aim to provision, the key-name refers to the previously generated key pair that was generated. It is a best practice to always provision 
EC2 instances with a key pair for maximum security and finally the security group id of the security group created earlier.
[Image]
To check the state of the instance, i.e. to determine whether I was now able to interact with the instance via SSH, I used the command aws 'ec2 describe-instance-status -- instance-id i-0121258e7fc8d5a6' #replace id with your own instance id which can be found from the json output of the previously excecuted command.
Once it was ready, I SSH'ed into the instance using 'command' command.
[image]
Since my node.js app project folder was on my local machine, i used scp i.e. a file transfer tool to copy my app into my instance.
as show below.the command used was 'scp -i vockey.pem C:\Users\silas\Downloads\Compressed\node-app.zip ec2-user@44.251.58.162 :~'. The -i option is used
to specify the key pair used to gain secure access to the instance followed by the path of the application folder on my local machine and the username, IP and location the file is to be sent to represented by the tilde(~)
[image]
Upon receiving the file on my instance, i unzipped the contents as shown below
[image]
Then i proceeded to install nodejs using 'curl -sL https://rpm. nodesource. com/setup_18.x | sudo bash -
sudo yum install -y nodejs' and then npm using 'npm install'.
[image] [image]
By default, nodejs apps are served through port 3000 hence why i opened port 3000 when creating the security group. After using the command 'node server.js',
i tested to check whether the application could be reached on port 3000 using 'http://EC2_PUBLIC_IP:3000' and it was reachable.
[image] [image]
After stopping the server, I decided to install PM2, a production process manager for Node.js applications which has some useful features such as
background running, process monitoring, auto start on reboot, log management among others. it also keeps the app alive even if i log out.
[image].
From there i decided to setup a reverse proxy using nginx. With the configuration of the application at the time, it meant that port 3000 was exposed meaning it would be a field day
for hackers to steal information or deface the webpage had this been a proper website. Hence using nginx as a reverse proxy would make the application a bit more secure.
I used 'sudo amazon-linux-extras enable nginx1 sudo yum install -y nginx' as seen below to install the nginx server.
[image].
  Then i used the commands 'sudo systemctl start nginx' and 'sudo systemctl enable nginx' to start the server which could now be reached from port 80 using 'http://<your-ec2-ip>' .
[image]
I then created a config file for my proxy server using 'sudo nano /etc/nginx/conf.d/node-app.conf
' and made the configurations seen below.
  [image]
After testing the config with 'sudo nginx -t' and reloading the server with 'sudo systemctl reload nginx
', I was now able to reach the app using my EC2 public IP without exposing port 3000.
[image]







  
